(function(r,y){typeof exports=="object"&&typeof module<"u"?y(exports):typeof define=="function"&&define.amd?define(["exports"],y):(r=typeof globalThis<"u"?globalThis:r||self,y(r.madoi={}))})(this,function(r){"use strict";var Y=Object.defineProperty;var Z=(r,y,M)=>y in r?Y(r,y,{enumerable:!0,configurable:!0,writable:!0,value:M}):r[y]=M;var h=(r,y,M)=>Z(r,typeof y!="symbol"?y+"":y,M);class y extends EventTarget{dispatchCustomEvent(d,e){return super.dispatchEvent(new CustomEvent(d,{detail:e}))}}const M={sender:"__PEER__",castType:"PEERTOSERVER",recipients:void 0},_={sender:"__PEER__",castType:"BROADCAST",recipients:void 0},C={sender:"__PEER__",recipients:void 0};function I(s=void 0){return{type:"Ping",...M,body:s}}function D(s){return{type:"EnterRoom",...M,...s}}function $(s){return{type:"LeaveRoom",...M,...s}}function S(s){return{type:"UpdateRoomProfile",..._,...s}}function b(s){return{type:"UpdatePeerProfile",..._,...s}}function E(s){return{type:"DefineFunction",...M,...s}}function j(s){return{type:"DefineObject",...M,...s}}function T(s,d){return{type:"InvokeFunction",castType:s,...C,...d}}function U(s){return{type:"UpdateObjectState",...M,...s}}function A(s,d){return{type:"InvokeMethod",castType:s,...C,...d}}function F(s={}){return d=>{d.madoiClassConfig_=s}}const w={type:"beforeExec",maxLog:0,allowedTo:["USER"]};function N(s=w){const d=s;return d.type||(d.type="beforeExec"),d.maxLog||(d.maxLog=0),(e,t,n)=>{const o={share:d};e[t].madoiMethodConfig_=o}}const R={type:"beforeExec"};function k(s=R){const d={...s};return(e,t,n)=>{const o={notify:d};e[t].madoiMethodConfig_=o}}const O={maxInterval:5e3};function x(s=O){const d=s;return(e,t,n)=>{const o={getState:d};e[t].madoiMethodConfig_=o}}function H(s={}){const d=s;return(e,t,n)=>{const o={setState:d};e[t].madoiMethodConfig_=o}}function B(s={}){return(d,e,t)=>{const o={hostOnly:s};d[e].madoiMethodConfig_=o}}function J(s={}){const d=s;return(e,t,n)=>{const o={beforeEnterRoom:d};e[t].madoiMethodConfig_=o}}function G(s={}){const d=s;return(e,t,n)=>{const o={enterRoomAllowed:d};e[t].madoiMethodConfig_=o}}function Q(s={}){const d=s;return(e,t,n)=>{const o={enterRoomDenied:d};e[t].madoiMethodConfig_=o}}function z(s={}){const d=s;return(e,t,n)=>{const o={leaveRoomDone:d};e[t].madoiMethodConfig_=o}}function q(s={}){const d=s;return(e,t,n)=>{const o={roomProfileUpdated:d};e[t].madoiMethodConfig_=o}}function V(s={}){const d=s;return(e,t,n)=>{const o={peerEntered:d};e[t].madoiMethodConfig_=o}}function W(s={}){const d=s;return(e,t,n)=>{const o={peerLeaved:d};e[t].madoiMethodConfig_=o}}function K(s={}){const d=s;return(e,t,n)=>{const o={peerProfileUpdated:d};e[t].madoiMethodConfig_=o}}class X extends y{constructor(e,t,n,o){super();h(this,"connecting",!1);h(this,"interimQueue");h(this,"shareOrNotifyFunctions",new Map);h(this,"shareObjects",new Map);h(this,"shareOrNotifyMethods",new Map);h(this,"getStateMethods",new Map);h(this,"setStateMethods",new Map);h(this,"beforeEnterRoomMethods",new Map);h(this,"enterRoomAllowedMethods",new Map);h(this,"enterRoomDeniedMethods",new Map);h(this,"leaveRoomDoneMethods",new Map);h(this,"roomProfileUpdatedMethods",new Map);h(this,"peerEnteredMethods",new Map);h(this,"peerLeavedMethods",new Map);h(this,"peerProfileUpdatedMethods",new Map);h(this,"url");h(this,"ws",null);h(this,"room",{id:"",spec:{maxLog:1e3},profile:{}});h(this,"selfPeer",{id:"",order:-1,profile:{}});h(this,"peers",new Map);h(this,"currentSenderId",null);h(this,"systemMessageTypes",["Ping","Pong","EnterRoom","EnterRoomAllowed","EnterRoomDenied","LeaveRoom","LeaveRoomDone","UpdateRoomProfile","PeerArrived","PeerLeaved","UpdatePeerProfile","DefineFunction","DefineObject","InvokeFunction","UpdateObjectState","InvokeMethod"]);o&&(this.room={...this.room,...o}),n&&(this.selfPeer={...this.selfPeer,...n,order:-1}),this.interimQueue=new Array;const i=e.indexOf("?")!=-1?"&":"?";if(e.match(/^wss?:\/\//))this.url=`${e}${i}authToken=${t}`,this.room.id=e.split("rooms/")[1].split("?")[0];else{const a=document.querySelector("script[src$='madoi.js']").src.split("/",5),u=(a[0]=="http:"?"ws:":"wss:")+"//"+a[2]+"/"+a[3];this.url=`${u}/rooms/${e}${i}authToken=${t}`,this.room.id=e}this.ws=new WebSocket(this.url),this.ws.onopen=a=>this.handleOnOpen(a),this.ws.onclose=a=>this.handleOnClose(a),this.ws.onerror=a=>this.handleOnError(a),this.ws.onmessage=a=>this.handleOnMessage(a),setInterval(()=>{this.saveStates()},1e3),setInterval(()=>{this.sendPing()},3e4)}getRoomId(){return this.room.id}getRoomProfile(){var e;return(e=this.room)==null?void 0:e.profile}setRoomProfile(e,t){const n={};n[e]=t,this.sendMessage(S({updates:n}))}removeRoomProfile(e){this.sendMessage(S({deletes:[e]}))}getSelfPeerId(){var e;return(e=this.selfPeer)==null?void 0:e.id}getSelfPeerProfile(){return this.selfPeer.profile}updateSelfPeerProfile(e,t){this.selfPeer.profile[e]=t;const n={};n[e]=t,this.sendMessage(b({updates:n}));const o={updates:n,peerId:this.selfPeer.id};for(const[i,a]of this.peerProfileUpdatedMethods)a(o,this);this.dispatchCustomEvent("peerProfileUpdated",o)}removeSelfPeerProfile(e){delete this.selfPeer.profile[e],this.sendMessage(b({deletes:[e]}));const t={deletes:[e],peerId:this.selfPeer.id};for(const[n,o]of this.peerProfileUpdatedMethods)o(t,this);this.dispatchCustomEvent("peerProfileUpdated",t)}isMessageProcessing(){return this.currentSenderId!==null}getCurrentSender(){return this.currentSenderId===null?null:this.peers.get(this.currentSenderId)}isCurrentSenderSelf(){return this.currentSenderId===this.selfPeer.id}close(){var e;(e=this.ws)==null||e.close(),this.ws=null}sendPing(){var e;(e=this.ws)==null||e.send(JSON.stringify(I()))}handleOnOpen(e){var t;this.connecting=!0;for(const[n,o]of this.beforeEnterRoomMethods)o(this.selfPeer.profile,this);this.doSendMessage(D({room:this.room,selfPeer:this.selfPeer}));for(let n of this.interimQueue)(t=this.ws)==null||t.send(JSON.stringify(n));this.interimQueue=[]}handleOnClose(e){console.debug(`websocket closed because: ${e.reason}.`),this.connecting=!1,this.ws=null}handleOnError(e){}handleOnMessage(e){const t=JSON.parse(e.data);this.currentSenderId=t.sender;try{this.data(t)}finally{this.currentSenderId=null}}data(e){if(e.type!="Pong")if(e.type==="EnterRoomAllowed"){const t=e;for(const[n,o]of this.enterRoomAllowedMethods)o(t,this);this.room=e.room,this.selfPeer.order=e.selfPeer.order,this.peers.set(t.selfPeer.id,{...t.selfPeer,profile:this.selfPeer.profile});for(const n of t.otherPeers)this.peers.set(n.id,n);if(this.dispatchCustomEvent("enterRoomAllowed",t),e.histories)for(const n of e.histories)this.data(n)}else if(e.type==="EnterRoomDenied"){const n=e;for(const[o,i]of this.enterRoomDeniedMethods)i(n,this);this.dispatchCustomEvent("enterRoomDenied",n)}else if(e.type=="LeaveRoomDone"){for(const[t,n]of this.leaveRoomDoneMethods)n(this);this.dispatchCustomEvent("leaveRoomDone")}else if(e.type==="UpdateRoomProfile"){const t=e;if(e.updates)for(const[n,o]of Object.entries(e.updates))this.room.profile[n]=o;if(e.deletes)for(const n of e.deletes)delete this.room.profile[n];for(const[n,o]of this.roomProfileUpdatedMethods)o(t,this);this.dispatchCustomEvent("roomProfileUpdated",t)}else if(e.type==="PeerEntered"){const t=e;this.peers.set(t.peer.id,t.peer);for(const[n,o]of this.peerEnteredMethods)o(t,this);this.dispatchCustomEvent("peerEntered",t)}else if(e.type==="PeerLeaved"){const t=e;this.peers.delete(e.peerId);for(const[n,o]of this.peerLeavedMethods)o(t,this);this.dispatchCustomEvent("peerLeaved",t)}else if(e.type==="UpdatePeerProfile"){const t=this.peers.get(e.sender);if(e.sender&&t){if(e.updates)for(const[o,i]of Object.entries(e.updates))t.profile[o]=i;if(e.deletes)for(const o of e.deletes)delete t.profile[o];const n={...e,peerId:e.sender};for(const[o,i]of this.peerProfileUpdatedMethods)i(n,this);this.dispatchCustomEvent("peerProfileUpdated",n)}}else if(e.type==="InvokeFunction"){const t=`${e.funcId}`,n=this.shareOrNotifyFunctions.get(t);if(n===void 0){console.warn("no suitable function for ",e);return}const o=this.applyInvocation(n.original,e.args);o instanceof Promise&&o.then(()=>{var i;(i=n.resolve)==null||i.apply(null,arguments)}).catch(()=>{var i;(i=n.reject)==null||i.apply(null,arguments)})}else if(e.type==="UpdateObjectState"){const t=this.setStateMethods.get(e.objId);t&&t(e.state,e.objRevision);const n=this.shareObjects.get(e.objId);n&&(n.revision=e.objRevision)}else if(e.type==="InvokeMethod"){const t=this.shareObjects.get(e.objId);if(t===void 0){console.error(`Object not found for id: ${e.objId}.`,e);return}const n=`${e.objId}:${e.methodId}`,o=this.shareOrNotifyMethods.get(n);if(o===void 0){console.error(`Method not found for id: ${n}.`,e);return}o.config.share&&(t.revision+1!==e.serverObjRevision&&console.error(`Found inconsistency. serverObjRevision must be ${t.revision+1} but ${e.serverObjRevision}.`,e),t.revision=e.serverObjRevision);const i=this.applyInvocation(o.original,e.args);i instanceof Promise&&i.then(()=>{var a;(a=o.resolve)==null||a.apply(null,arguments)}).catch(()=>{var a;(a=o.reject)==null||a.apply(null,arguments)})}else e.type?this.dispatchEvent(new CustomEvent(e.type,{detail:e})):console.warn("Unknown message type.",e)}isSystemMessageType(e){return e in this.systemMessageTypes}send(e,t,n="BROADCAST"){this.ws&&this.sendMessage({type:e,sender:this.selfPeer.id,castType:n,recipients:void 0,content:t})}unicast(e,t,n){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"UNICAST",recipients:[n],content:t})}multicast(e,t,n){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"MULTICAST",recipients:n,content:t})}broadcast(e,t){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"BROADCAST",recipients:void 0,content:t})}othercast(e,t){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"OTHERCAST",recipients:void 0,content:t})}sendMessage(e){if(this.isSystemMessageType(e.type))throw new Error("システムメッセージは送信できません。");this.doSendMessage(e)}addReceiver(e,t){if(this.isSystemMessageType(e))throw new Error("システムメッセージのレシーバは登録できません。");this.addEventListener(e,t)}removeReceiver(e,t){this.removeEventListener(e,t)}replacer(e,t){return t instanceof Map?Object.fromEntries(t):t}doSendMessage(e){var t;this.connecting?(t=this.ws)==null||t.send(JSON.stringify(e,this.replacer)):this.interimQueue.push(e)}registerFunction(e,t={share:{}}){if("hostOnly"in t)return this.addHostOnlyFunction(e,t);if("notify"in t){t.notify.type||(t.notify.type=R.type);const n=e.name,o=this.shareOrNotifyFunctions.size,i=this.createFunctionProxy(e,{notify:t.notify},o),a=function(){return i.apply(null,arguments)};return this.doSendMessage(E({definition:{funcId:o,name:n,config:t}})),a}else if("share"in t){t.share.type||(t.share.type=w.type),t.share.maxLog||(t.share.maxLog=w.maxLog);const n=e.name,o=this.shareOrNotifyFunctions.size,i=this.createFunctionProxy(e,{share:t.share},o),a=function(){return i.apply(null,arguments)};return this.doSendMessage(E({definition:{funcId:o,name:n,config:t}})),a}return e}register(e,t=[]){if(!this.ws)return e;const n=e;if(n.madoiObjectId_)return console.warn("Ignore object registration because it's already registered."),e;let o=n.constructor.name;n.__proto__.constructor.madoiClassConfig_&&(o=n.__proto__.constructor.madoiClassConfig_.className);const i=this.shareObjects.size,a={instance:n,revision:0,modification:0};this.shareObjects.set(i,a),n.madoiObjectId_=i;const u=new Array,m=new Array,v=new Map;Object.getOwnPropertyNames(Object.getPrototypeOf(n)).forEach(p=>{const l=n[p];if(typeof l!="function"||!l.madoiMethodConfig_)return;const f=l.madoiMethodConfig_,c=u.length;v.set(p,c),u.push(l),m.push({methodId:c,name:p,config:f}),console.debug(`add config ${o}.${p}=${JSON.stringify(f)} from decorator`)});for(const p of t){const l=p.method,f=p,c=l.name;if("share"in f)f.share.type||(f.share.type=w.type),f.share.maxLog||(f.share.maxLog=w.maxLog);else if("notify"in f)f.notify.type||(f.notify.type=R.type);else if(!("hostOnly"in f)){if("getState"in f)f.getState.maxInterval||(f.getState.maxInterval=O.maxInterval);else if(!("setState"in f)){if(!("enterRoomAllowed"in f)){if(!("enterRoomDenied"in f)){if(!("leaveRoomDone"in f)){if(!("peerEntered"in f)){if(!("peerLeaved"in f))continue}}}}}}const g=v.get(c);if(typeof g>"u"){const L=u.length;v.set(c,L),u.push(l),m.push({methodId:L,name:p.method.name,config:f}),console.debug(`add config ${o}.${c}=${JSON.stringify(p)} from argument`)}else m[g].config=p,console.debug(`replace config ${o}.${c}=${JSON.stringify(p)} from argument`)}for(let p=0;p<u.length;p++){const l=u[p],f=m[p],c=f.config;if("share"in c){const g=this.createMethodProxy(l.bind(n),{share:c.share},i,f.methodId);n[f.name]=function(){return a.modification++,g.apply(null,arguments)}}else if("notify"in c){const g=this.createMethodProxy(l.bind(n),{notify:c.notify},i,f.methodId);n[f.name]=function(){return g.apply(null,arguments)}}else if("hostOnly"in c){const g=this.addHostOnlyFunction(l.bind(n),c.hostOnly);n[f.name]=function(){return a.modification++,g.apply(null,arguments)}}else"getState"in c?this.getStateMethods.set(i,{method:l.bind(n),config:c.getState,lastGet:0}):"setState"in c?this.setStateMethods.set(i,l.bind(n)):"beforeEnterRoom"in c?this.beforeEnterRoomMethods.set(i,l.bind(n)):"enterRoomAllowed"in c?this.enterRoomAllowedMethods.set(i,l.bind(n)):"enterRoomDenied"in c?this.enterRoomDeniedMethods.set(i,l.bind(n)):"leaveRoomDone"in c?this.leaveRoomDoneMethods.set(i,l.bind(n)):"peerEntered"in c?this.peerEnteredMethods.set(i,l.bind(n)):"peerProfileUpdated"in c?this.peerProfileUpdatedMethods.set(i,l.bind(n)):"peerLeaved"in c&&this.peerLeavedMethods.set(i,l.bind(n))}const P=j({definition:{objId:i,className:o,methods:m}});return this.doSendMessage(P),e}createFunctionProxy(e,t,n){const o=`${n}`,i={original:e,config:t};this.shareOrNotifyFunctions.set(o,i),i.promise=new Promise((u,m)=>{i.resolve=u,i.reject=m});const a=this;return function(){var u,m;if(a.ws===null){if(e)return e.apply(null,arguments)}else{let v=null,P="BROADCAST";return(((u=t.share)==null?void 0:u.type)==="afterExec"||((m=t.notify)==null?void 0:m.type)==="afterExec")&&(v=e.apply(null,arguments),P="OTHERCAST"),a.sendMessage(T(P,{funcId:n,args:Array.from(arguments)})),v??i.promise}}}createMethodProxy(e,t,n,o){const i=`${n}:${o}`,a={original:e,config:t};this.shareOrNotifyMethods.set(i,a),a.promise=new Promise((m,v)=>{a.resolve=m,a.reject=v});const u=this;return function(){var m,v;if(u.ws===null){if(e)return e.apply(null,[...arguments,u])}else{let P=null,p="BROADCAST",l=u.shareObjects.get(n).revision;return(((m=t.share)==null?void 0:m.type)==="afterExec"||((v=t.notify)==null?void 0:v.type)==="afterExec")&&(P=e.apply(null,[...arguments,u]),t.share&&l++,p="OTHERCAST"),u.sendMessage(A(p,{objId:n,objRevision:l,methodId:o,args:Array.from(arguments)})),P??a.promise}}}addHostOnlyFunction(e,t){const n=this;return function(){let o=n.selfPeer.order;for(const i of n.peers.values())o>i.order&&(o=i.order);n.selfPeer.order===o&&e.apply(null,[...arguments,n])}}saveStates(){if(!(!this.ws||!this.connecting))for(let[e,t]of this.shareObjects){if(t.modification==0)continue;const n=this.getStateMethods.get(e);if(!n)continue;const o=performance.now();(n.config.maxUpdates&&n.config.maxUpdates<=t.modification||n.config.maxInterval&&n.config.maxInterval<=o-n.lastGet)&&(this.doSendMessage(U({objId:e,objRevision:t.revision,state:n.method(this)})),n.lastGet=o,t.modification=0,console.debug(`state saved: ${e}`))}}applyInvocation(e,t){return e.apply(null,t)}}r.BeforeEnterRoom=J,r.EnterRoomAllowed=G,r.EnterRoomDenied=Q,r.GetState=x,r.HostOnly=B,r.LeaveRoomDone=z,r.Madoi=X,r.Notify=k,r.PeerEntered=V,r.PeerLeaved=W,r.PeerProfileUpdated=K,r.RoomProfileUpdated=q,r.SetState=H,r.Share=N,r.ShareClass=F,r.getStateConfigDefault=O,r.newDefineFunction=E,r.newDefineObject=j,r.newEnterRoom=D,r.newInvokeFunction=T,r.newInvokeMethod=A,r.newLeaveRoom=$,r.newPing=I,r.newUpdateObjectState=U,r.newUpdatePeerProfile=b,r.newUpdateRoomProfile=S,r.notifyConfigDefault=R,r.shareConfigDefault=w,Object.defineProperty(r,Symbol.toStringTag,{value:"Module"})});
