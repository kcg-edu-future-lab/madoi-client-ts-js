(function(s,y){typeof exports=="object"&&typeof module<"u"?y(exports):typeof define=="function"&&define.amd?define(["exports"],y):(s=typeof globalThis<"u"?globalThis:s||self,y(s.madoi={}))})(this,function(s){"use strict";var le=Object.defineProperty;var ce=(s,y,v)=>y in s?le(s,y,{enumerable:!0,configurable:!0,writable:!0,value:v}):s[y]=v;var h=(s,y,v)=>ce(s,typeof y!="symbol"?y+"":y,v);class y extends EventTarget{dispatchCustomEvent(a,e){return super.dispatchEvent(new CustomEvent(a,{detail:e}))}}const v={sender:"__PEER__",castType:"PEERTOSERVER",recipients:void 0},C={sender:"__PEER__",castType:"BROADCAST",recipients:void 0},O={sender:"__PEER__",recipients:void 0};function D(i=void 0){return{type:"Ping",...v,body:i}}function _(i){return{type:"EnterRoom",...v,...i}}function q(i){return{type:"LeaveRoom",...v,...i}}function P(i){return{type:"UpdateRoomProfile",...C,...i}}function R(i){return{type:"UpdatePeerProfile",...C,...i}}function w(i){return{type:"DefineFunction",...v,...i}}function A(i){return{type:"DefineObject",...v,...i}}function j(i,a){return{type:"InvokeFunction",castType:i,...O,...a}}function I(i){return{type:"UpdateObjectState",...v,...i}}function U(i,a){return{type:"InvokeMethod",castType:i,...O,...a}}function V(i={}){return a=>{a.madoiClassConfig_=i}}function W(i={}){return(a,e,t)=>{a[e].madoiMethodConfig_={share:i}}}function K(i={}){return(a,e,t)=>{a[e].madoiMethodConfig_={notify:i}}}function X(i={}){return(a,e,t)=>{a[e].madoiMethodConfig_={getState:i}}}function Y(i={}){return(a,e,t)=>{a[e].madoiMethodConfig_={setState:i}}}function Z(i={}){return(a,e,t)=>{a[e].madoiMethodConfig_={hostOnly:i}}}function x(i={}){return(a,e,t)=>{a[e].madoiMethodConfig_={beforeEnterRoom:i}}}function ee(i={}){return(a,e,t)=>{a[e].madoiMethodConfig_={enterRoomAllowed:i}}}function te(i={}){return(a,e,t)=>{a[e].madoiMethodConfig_={enterRoomDenied:i}}}function oe(i={}){return(a,e,t)=>{a[e].madoiMethodConfig_={leaveRoomDone:i}}}function ne(i={}){return(a,e,t)=>{a[e].madoiMethodConfig_={roomProfileUpdated:i}}}function se(i={}){return(a,e,t)=>{a[e].madoiMethodConfig_={peerEntered:i}}}function ie(i={}){return(a,e,t)=>{a[e].madoiMethodConfig_={peerLeaved:i}}}function re(i={}){return(a,e,t)=>{a[e].madoiMethodConfig_={peerProfileUpdated:i}}}function de(i){return(a,e,t)=>{a[e].madoiMethodConfig_={userMessageArrived:i}}}const S={type:"beforeExec"},E={type:"beforeExec"},T={maxInterval:5e3},$={},L={},F={},N={},k={},H={},ae={},B={},J={},G={},Q={};class fe extends y{constructor(e,t,o,n){super();h(this,"connecting",!1);h(this,"interimQueue");h(this,"shareOrNotifyFunctions",new Map);h(this,"shareObjects",new Map);h(this,"shareOrNotifyMethods",new Map);h(this,"getStateMethods",new Map);h(this,"setStateMethods",new Map);h(this,"beforeEnterRoomMethods",new Map);h(this,"enterRoomAllowedMethods",new Map);h(this,"enterRoomDeniedMethods",new Map);h(this,"leaveRoomDoneMethods",new Map);h(this,"roomProfileUpdatedMethods",new Map);h(this,"peerEnteredMethods",new Map);h(this,"peerLeavedMethods",new Map);h(this,"peerProfileUpdatedMethods",new Map);h(this,"userMessageArrivedMethods",[]);h(this,"url");h(this,"ws",null);h(this,"room",{id:"",spec:{maxLog:1e3},profile:{}});h(this,"selfPeer",{id:"",order:-1,profile:{}});h(this,"peers",new Map);h(this,"currentSenderId",null);h(this,"systemMessageTypes",["Ping","Pong","EnterRoom","EnterRoomAllowed","EnterRoomDenied","LeaveRoom","LeaveRoomDone","UpdateRoomProfile","PeerArrived","PeerLeaved","UpdatePeerProfile","DefineFunction","DefineObject","InvokeFunction","UpdateObjectState","InvokeMethod"]);n&&(this.room={...this.room,...n}),o&&(this.selfPeer={...this.selfPeer,...o,order:-1}),this.interimQueue=new Array;const r=e.indexOf("?")!=-1?"&":"?";if(e.match(/^wss?:\/\//))this.url=`${e}${r}authToken=${t}`,this.room.id=e.split("rooms/")[1].split("?")[0];else{const f=document.querySelector("script[src$='madoi.js']").src.split("/",5),u=(f[0]=="http:"?"ws:":"wss:")+"//"+f[2]+"/"+f[3];this.url=`${u}/rooms/${e}${r}authToken=${t}`,this.room.id=e}this.ws=new WebSocket(this.url),this.ws.onopen=f=>this.handleOnOpen(f),this.ws.onclose=f=>this.handleOnClose(f),this.ws.onerror=f=>this.handleOnError(f),this.ws.onmessage=f=>this.handleOnMessage(f),setInterval(()=>{this.saveStates()},1e3),setInterval(()=>{this.sendPing()},3e4)}getRoomId(){return this.room.id}getRoomProfile(){var e;return(e=this.room)==null?void 0:e.profile}setRoomProfile(e,t){const o={};o[e]=t,this.sendMessage(P({updates:o}))}removeRoomProfile(e){this.sendMessage(P({deletes:[e]}))}getSelfPeerId(){var e;return(e=this.selfPeer)==null?void 0:e.id}getSelfPeerProfile(){return this.selfPeer.profile}updateSelfPeerProfile(e,t){this.selfPeer.profile[e]=t;const o={};o[e]=t,this.sendMessage(R({updates:o}));const n={updates:o,peerId:this.selfPeer.id};for(const[r,f]of this.peerProfileUpdatedMethods)f(n,this);this.dispatchCustomEvent("peerProfileUpdated",n)}removeSelfPeerProfile(e){delete this.selfPeer.profile[e],this.sendMessage(R({deletes:[e]}));const t={deletes:[e],peerId:this.selfPeer.id};for(const[o,n]of this.peerProfileUpdatedMethods)n(t,this);this.dispatchCustomEvent("peerProfileUpdated",t)}isMessageProcessing(){return this.currentSenderId!==null}getCurrentSender(){return this.currentSenderId===null?null:this.peers.get(this.currentSenderId)}isCurrentSenderSelf(){return this.currentSenderId===this.selfPeer.id}close(){var e;(e=this.ws)==null||e.close(),this.ws=null}sendPing(){var e;(e=this.ws)==null||e.send(JSON.stringify(D()))}handleOnOpen(e){var t;this.connecting=!0;for(const[o,n]of this.beforeEnterRoomMethods)n(this.selfPeer.profile,this);this.doSendMessage(_({room:this.room,selfPeer:this.selfPeer}));for(let o of this.interimQueue)(t=this.ws)==null||t.send(JSON.stringify(o));this.interimQueue=[]}handleOnClose(e){console.debug(`websocket closed because: ${e.reason}.`),this.connecting=!1,this.ws=null}handleOnError(e){}handleOnMessage(e){const t=JSON.parse(e.data);this.currentSenderId=t.sender;try{this.data(t)}finally{this.currentSenderId=null}}data(e){if(e.type!="Pong")if(e.type==="EnterRoomAllowed"){const t=e;for(const[o,n]of this.enterRoomAllowedMethods)n(t,this);this.room=e.room,this.selfPeer.order=e.selfPeer.order,this.peers.set(t.selfPeer.id,{...t.selfPeer,profile:this.selfPeer.profile});for(const o of t.otherPeers)this.peers.set(o.id,o);if(this.dispatchCustomEvent("enterRoomAllowed",t),e.histories)for(const o of e.histories)this.data(o)}else if(e.type==="EnterRoomDenied"){const o=e;for(const[n,r]of this.enterRoomDeniedMethods)r(o,this);this.dispatchCustomEvent("enterRoomDenied",o)}else if(e.type=="LeaveRoomDone"){for(const[t,o]of this.leaveRoomDoneMethods)o(this);this.dispatchCustomEvent("leaveRoomDone")}else if(e.type==="UpdateRoomProfile"){const t=e;if(e.updates)for(const[o,n]of Object.entries(e.updates))this.room.profile[o]=n;if(e.deletes)for(const o of e.deletes)delete this.room.profile[o];for(const[o,n]of this.roomProfileUpdatedMethods)n(t,this);this.dispatchCustomEvent("roomProfileUpdated",t)}else if(e.type==="PeerEntered"){const t=e;this.peers.set(t.peer.id,t.peer);for(const[o,n]of this.peerEnteredMethods)n(t,this);this.dispatchCustomEvent("peerEntered",t)}else if(e.type==="PeerLeaved"){const t=e;this.peers.delete(e.peerId);for(const[o,n]of this.peerLeavedMethods)n(t,this);this.dispatchCustomEvent("peerLeaved",t)}else if(e.type==="UpdatePeerProfile"){const t=this.peers.get(e.sender);if(e.sender&&t){if(e.updates)for(const[n,r]of Object.entries(e.updates))t.profile[n]=r;if(e.deletes)for(const n of e.deletes)delete t.profile[n];const o={...e,peerId:e.sender};for(const[n,r]of this.peerProfileUpdatedMethods)r(o,this);this.dispatchCustomEvent("peerProfileUpdated",o)}}else if(e.type==="InvokeFunction"){const t=`${e.funcId}`,o=this.shareOrNotifyFunctions.get(t);if(o===void 0){console.warn("no suitable function for ",e);return}const n=this.applyInvocation(o.original,e.args);n instanceof Promise&&n.then(()=>{var r;(r=o.resolve)==null||r.apply(null,arguments)}).catch(()=>{var r;(r=o.reject)==null||r.apply(null,arguments)})}else if(e.type==="UpdateObjectState"){const t=this.setStateMethods.get(e.objId);t&&t(e.state,e.objRevision);const o=this.shareObjects.get(e.objId);o&&(o.revision=e.objRevision,o.update=0)}else if(e.type==="InvokeMethod"){const t=this.shareObjects.get(e.objId);if(t===void 0){console.error(`Object not found for id: ${e.objId}.`,e);return}const o=`${e.objId}:${e.methodId}`,n=this.shareOrNotifyMethods.get(o);if(n===void 0){console.error(`Method not found for id: ${o}.`,e);return}n.config.share&&(n.config.share.type=="beforeExec"&&t.revision+1!==e.serverObjRevision&&console.error(`Found inconsistency. serverObjRevision must be ${t.revision+1} but ${e.serverObjRevision}.`,e),t.revision++,t.update++);const r=this.applyInvocation(n.original,e.args);r instanceof Promise&&r.then(function(){var f;(f=n.resolve)==null||f.apply(null,arguments)}).catch(function(){var f;(f=n.reject)==null||f.apply(null,arguments)})}else if(e.type){const t=e;for(const o of this.userMessageArrivedMethods)o.config.type===e.type&&o.method(t,this);this.dispatchEvent(new CustomEvent(e.type,{detail:e}))}else console.warn("Unknown message type.",e)}isSystemMessageType(e){return e in this.systemMessageTypes}send(e,t,o="BROADCAST"){this.ws&&this.sendMessage({type:e,sender:this.selfPeer.id,castType:o,recipients:void 0,content:t})}unicast(e,t,o){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"UNICAST",recipients:[o],content:t})}multicast(e,t,o){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"MULTICAST",recipients:o,content:t})}broadcast(e,t){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"BROADCAST",recipients:void 0,content:t})}othercast(e,t){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"OTHERCAST",recipients:void 0,content:t})}sendMessage(e){if(this.isSystemMessageType(e.type))throw new Error("システムメッセージは送信できません。");this.doSendMessage(e)}addReceiver(e,t){if(this.isSystemMessageType(e))throw new Error("システムメッセージのレシーバは登録できません。");this.addEventListener(e,t)}removeReceiver(e,t){this.removeEventListener(e,t)}replacer(e,t){return t instanceof Map?Object.fromEntries(t):t}doSendMessage(e){var t;this.connecting?(t=this.ws)==null||t.send(JSON.stringify(e,this.replacer)):this.interimQueue.push(e)}registerFunction(e,t={share:{}}){if("hostOnly"in t)return this.addHostOnlyFunction(e,t.hostOnly);if("notify"in t){t={notify:{...E,...t.notify}};const o=e.name,n=this.shareOrNotifyFunctions.size,r=this.createFunctionProxy(e,{notify:t.notify},n),f=function(){return r.apply(null,arguments)};return this.doSendMessage(w({definition:{funcId:n,name:o,config:t}})),f}else if("share"in t){t={share:{...S,...t.share}};const o=e.name,n=this.shareOrNotifyFunctions.size,r=this.createFunctionProxy(e,{share:t.share},n),f=function(){return r.apply(null,arguments)};return this.doSendMessage(w({definition:{funcId:n,name:o,config:t}})),f}return e}register(e,t=[]){if(!this.ws)return e;const o=e;if(o.madoiObjectId_)return console.warn("Ignore object registration because it's already registered."),e;let n=o.constructor.name;o.__proto__.constructor.madoiClassConfig_&&(n=o.__proto__.constructor.madoiClassConfig_.className);const r=this.shareObjects.size,f={instance:o,revision:0,update:0};this.shareObjects.set(r,f),o.madoiObjectId_=r;const u=new Array,m=new Array,g=new Map;Object.getOwnPropertyNames(Object.getPrototypeOf(o)).forEach(p=>{const c=o[p];if(typeof c!="function"||!c.madoiMethodConfig_)return;const l=c.madoiMethodConfig_,d=u.length;g.set(p,d),u.push(c),m.push({methodId:d,name:p,config:l}),console.debug(`add config ${n}.${p}=${JSON.stringify(l)} from decorator`)});for(const p of t){const c=p.method,l=p,d=c.name,b=g.get(d);if(typeof b>"u"){const z=u.length;g.set(d,z),u.push(c),m.push({methodId:z,name:p.method.name,config:l}),console.debug(`add config ${n}.${d}=${JSON.stringify(p)} from argument`)}else m[b].config={...m[b].config,...p},console.debug(`merge config ${n}.${d}=${JSON.stringify(p)} from argument`)}for(let p=0;p<u.length;p++){const c=u[p],l=m[p],d=l.config;"share"in d?(l.config={share:{...S,...d.share}},o[l.name]=this.createMethodProxy(c.bind(o),d,r,l.methodId)):"notify"in d?(l.config={notify:{...E,...d.notify}},o[l.name]=this.createMethodProxy(c.bind(o),d,r,l.methodId)):"hostOnly"in d?(l.config={hostOnly:{...L,...d.hostOnly}},o[l.name]=this.addHostOnlyFunction(c.bind(o),d.hostOnly,r)):"getState"in d?(l.config={getState:{...T,...d.getState}},this.getStateMethods.set(r,{method:c.bind(o),config:d.getState,lastGet:0})):"setState"in d?(l.config={setState:{...$,...d.setState}},this.setStateMethods.set(r,c.bind(o))):"beforeEnterRoom"in d?(l.config={beforeEnterRoom:{...F,...d.beforeEnterRoom}},this.beforeEnterRoomMethods.set(r,c.bind(o))):"enterRoomAllowed"in d?(l.config={enterRoomAllowed:{...N,...d.enterRoomAllowed}},this.enterRoomAllowedMethods.set(r,c.bind(o))):"enterRoomDenied"in d?(l.config={enterRoomDenied:{...k,...d.enterRoomDenied}},this.enterRoomDeniedMethods.set(r,c.bind(o))):"leaveRoomDone"in d?(l.config={leaveRoomDone:{...H,...d.leaveRoomDone}},this.leaveRoomDoneMethods.set(r,c.bind(o))):"peerEntered"in d?(l.config={peerEntered:{...B,...d.peerEntered}},this.peerEnteredMethods.set(r,c.bind(o))):"peerProfileUpdated"in d?(l.config={peerProfileUpdated:{...G,...d.peerProfileUpdated}},this.peerProfileUpdatedMethods.set(r,c.bind(o))):"peerLeaved"in d?(l.config={peerLeaved:{...J,...d.peerLeaved}},this.peerLeavedMethods.set(r,c.bind(o))):"userMessageArrived"in d&&(l.config={userMessageArrived:{type:"",...Q,...d.userMessageArrived}},this.userMessageArrivedMethods.push({method:c.bind(o),config:d.userMessageArrived}))}const M=A({definition:{objId:r,className:n,methods:m}});return this.doSendMessage(M),e}createFunctionProxy(e,t,o){const n=`${o}`,r={original:e,config:t};this.shareOrNotifyFunctions.set(n,r),r.promise=new Promise((u,m)=>{r.resolve=u,r.reject=m});const f=this;return function(){var u,m;if(f.ws===null){if(e)return e.apply(null,arguments)}else{let g=null,M="BROADCAST";return(((u=t.share)==null?void 0:u.type)==="afterExec"||((m=t.notify)==null?void 0:m.type)==="afterExec")&&(g=e.apply(null,arguments),M="OTHERCAST"),f.sendMessage(j(M,{funcId:o,args:Array.from(arguments)})),g??r.promise}}}createMethodProxy(e,t,o,n){const r=`${o}:${n}`,f={original:e,config:t};this.shareOrNotifyMethods.set(r,f),f.promise=new Promise((m,g)=>{f.resolve=m,f.reject=g});const u=this;return function(){var m,g;if(u.ws===null){if(e)return e.apply(null,[...arguments,u])}else{let M=null,p="BROADCAST";const c=u.shareObjects.get(o),l=c.revision;return(((m=t.share)==null?void 0:m.type)==="afterExec"||((g=t.notify)==null?void 0:g.type)==="afterExec")&&(M=e.apply(null,[...arguments,u]),t.share&&(c.revision++,c.update++),p="OTHERCAST"),u.sendMessage(U(p,{objId:o,objRevision:l,methodId:n,args:Array.from(arguments)})),M??f.promise}}}addHostOnlyFunction(e,t,o){const n=this;return function(){if(n.isSelfPeerHost()){if(o!==void 0){const r=n.shareObjects.get(o);r.revision++,r.update++}e.apply(null,[...arguments,n])}}}saveStates(){if(!(!this.ws||!this.connecting)&&this.isSelfPeerHost())for(let[e,t]of this.shareObjects){if(t.update==0)continue;const o=this.getStateMethods.get(e);if(!o)continue;const n=performance.now();(o.config.maxUpdates&&o.config.maxUpdates<=t.update||o.config.maxInterval&&o.config.maxInterval<=n-o.lastGet)&&(this.doSendMessage(I({objId:e,objRevision:t.revision,state:o.method(this)})),o.lastGet=n,t.update=0,console.debug(`state saved: ${e}`))}}applyInvocation(e,t){return e.apply(null,t)}isSelfPeerHost(){for(const e of this.peers.values())if(e.order<this.selfPeer.order)return!1;return!0}}s.BeforeEnterRoom=x,s.EnterRoomAllowed=ee,s.EnterRoomDenied=te,s.GetState=X,s.HostOnly=Z,s.LeaveRoomDone=oe,s.Madoi=fe,s.Notify=K,s.PeerEntered=se,s.PeerLeaved=ie,s.PeerProfileUpdated=re,s.RoomProfileUpdated=ne,s.SetState=Y,s.Share=W,s.ShareClass=V,s.UserMessageArrived=de,s.beforeEnterRoomConfigDefault=F,s.enterRoomAllowedConfigDefault=N,s.enterRoomDeniedConfigDefault=k,s.getStateConfigDefault=T,s.hostOnlyConfigDefault=L,s.leaveRoomDoneConfigDefault=H,s.newDefineFunction=w,s.newDefineObject=A,s.newEnterRoom=_,s.newInvokeFunction=j,s.newInvokeMethod=U,s.newLeaveRoom=q,s.newPing=D,s.newUpdateObjectState=I,s.newUpdatePeerProfile=R,s.newUpdateRoomProfile=P,s.notifyConfigDefault=E,s.peerEnteredConfigDefault=B,s.peerLeavedConfigDefault=J,s.peerProfileUpdatedConfigDefault=G,s.roomProfileUpdatedConfigDefault=ae,s.setStateConfigDefault=$,s.shareConfigDefault=S,s.userMessageArrivedConfigDefault=Q,Object.defineProperty(s,Symbol.toStringTag,{value:"Module"})});
