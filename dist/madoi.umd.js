(function(r,y){typeof exports=="object"&&typeof module<"u"?y(exports):typeof define=="function"&&define.amd?define(["exports"],y):(r=typeof globalThis<"u"?globalThis:r||self,y(r.madoi={}))})(this,function(r){"use strict";var Y=Object.defineProperty;var Z=(r,y,M)=>y in r?Y(r,y,{enumerable:!0,configurable:!0,writable:!0,value:M}):r[y]=M;var h=(r,y,M)=>Z(r,typeof y!="symbol"?y+"":y,M);class y extends EventTarget{dispatchCustomEvent(d,e){return super.dispatchEvent(new CustomEvent(d,{detail:e}))}}const M={sender:"__PEER__",castType:"PEERTOSERVER",recipients:void 0},O={sender:"__PEER__",castType:"BROADCAST",recipients:void 0},_={sender:"__PEER__",recipients:void 0};function C(s=void 0){return{type:"Ping",...M,body:s}}function j(s){return{type:"EnterRoom",...M,...s}}function $(s){return{type:"LeaveRoom",...M,...s}}function S(s){return{type:"UpdateRoomProfile",...O,...s}}function R(s){return{type:"UpdatePeerProfile",...O,...s}}function b(s){return{type:"DefineFunction",...M,...s}}function D(s){return{type:"DefineObject",...M,...s}}function I(s,d){return{type:"InvokeFunction",castType:s,..._,...d}}function T(s){return{type:"UpdateObjectState",...M,...s}}function U(s,d){return{type:"InvokeMethod",castType:s,..._,...d}}function F(s={}){return d=>{d.madoiClassConfig_=s}}const g={type:"beforeExec",maxLog:0,allowedTo:["USER"]};function N(s=g){const d=s;return d.type||(d.type="beforeExec"),d.maxLog||(d.maxLog=0),(e,t,o)=>{const n={share:d};e[t].madoiMethodConfig_=n}}const w={type:"beforeExec"};function k(s=w){const d={...s};return(e,t,o)=>{const n={notify:d};e[t].madoiMethodConfig_=n}}const E={maxInterval:5e3};function x(s=E){const d=s;return(e,t,o)=>{const n={getState:d};e[t].madoiMethodConfig_=n}}function H(s={}){const d=s;return(e,t,o)=>{const n={setState:d};e[t].madoiMethodConfig_=n}}function B(s={}){return(d,e,t)=>{const n={hostOnly:s};d[e].madoiMethodConfig_=n}}function J(s={}){const d=s;return(e,t,o)=>{const n={beforeEnterRoom:d};e[t].madoiMethodConfig_=n}}function G(s={}){const d=s;return(e,t,o)=>{const n={enterRoomAllowed:d};e[t].madoiMethodConfig_=n}}function Q(s={}){const d=s;return(e,t,o)=>{const n={enterRoomDenied:d};e[t].madoiMethodConfig_=n}}function z(s={}){const d=s;return(e,t,o)=>{const n={leaveRoomDone:d};e[t].madoiMethodConfig_=n}}function q(s={}){const d=s;return(e,t,o)=>{const n={roomProfileUpdated:d};e[t].madoiMethodConfig_=n}}function V(s={}){const d=s;return(e,t,o)=>{const n={peerEntered:d};e[t].madoiMethodConfig_=n}}function W(s={}){const d=s;return(e,t,o)=>{const n={peerLeaved:d};e[t].madoiMethodConfig_=n}}function K(s={}){const d=s;return(e,t,o)=>{const n={peerProfileUpdated:d};e[t].madoiMethodConfig_=n}}class X extends y{constructor(e,t,o,n){super();h(this,"connecting",!1);h(this,"interimQueue");h(this,"shareOrNotifyFunctions",new Map);h(this,"shareObjects",new Map);h(this,"shareOrNotifyMethods",new Map);h(this,"getStateMethods",new Map);h(this,"setStateMethods",new Map);h(this,"beforeEnterRoomMethods",new Map);h(this,"enterRoomAllowedMethods",new Map);h(this,"enterRoomDeniedMethods",new Map);h(this,"leaveRoomDoneMethods",new Map);h(this,"roomProfileUpdatedMethods",new Map);h(this,"peerEnteredMethods",new Map);h(this,"peerLeavedMethods",new Map);h(this,"peerProfileUpdatedMethods",new Map);h(this,"url");h(this,"ws",null);h(this,"room",{id:"",spec:{maxLog:1e3},profile:{}});h(this,"selfPeer",{id:"",order:-1,profile:{}});h(this,"peers",new Map);h(this,"currentSenderId",null);h(this,"systemMessageTypes",["Ping","Pong","EnterRoom","EnterRoomAllowed","EnterRoomDenied","LeaveRoom","LeaveRoomDone","UpdateRoomProfile","PeerArrived","PeerLeaved","UpdatePeerProfile","DefineFunction","DefineObject","InvokeFunction","UpdateObjectState","InvokeMethod"]);n&&(this.room={...this.room,...n}),o&&(this.selfPeer={...this.selfPeer,...o,order:-1}),this.interimQueue=new Array;const i=e.indexOf("?")!=-1?"&":"?";if(e.match(/^wss?:\/\//))this.url=`${e}${i}authToken=${t}`,this.room.id=e.split("rooms/")[1].split("?")[0];else{const a=document.querySelector("script[src$='madoi.js']").src.split("/",5),u=(a[0]=="http:"?"ws:":"wss:")+"//"+a[2]+"/"+a[3];this.url=`${u}/rooms/${e}${i}authToken=${t}`,this.room.id=e}this.ws=new WebSocket(this.url),this.ws.onopen=a=>this.handleOnOpen(a),this.ws.onclose=a=>this.handleOnClose(a),this.ws.onerror=a=>this.handleOnError(a),this.ws.onmessage=a=>this.handleOnMessage(a),setInterval(()=>{this.saveStates()},1e3),setInterval(()=>{this.sendPing()},3e4)}getRoomId(){return this.room.id}getRoomProfile(){var e;return(e=this.room)==null?void 0:e.profile}setRoomProfile(e,t){const o={};o[e]=t,this.sendMessage(S({updates:o}))}removeRoomProfile(e){this.sendMessage(S({deletes:[e]}))}getSelfPeerId(){var e;return(e=this.selfPeer)==null?void 0:e.id}getSelfPeerProfile(){return this.selfPeer.profile}updateSelfPeerProfile(e,t){this.selfPeer.profile[e]=t;const o={};o[e]=t,this.sendMessage(R({updates:o}));const n={updates:o,peerId:this.selfPeer.id};for(const[i,a]of this.peerProfileUpdatedMethods)a(n,this);this.dispatchCustomEvent("peerProfileUpdated",n)}removeSelfPeerProfile(e){delete this.selfPeer.profile[e],this.sendMessage(R({deletes:[e]}));const t={deletes:[e],peerId:this.selfPeer.id};for(const[o,n]of this.peerProfileUpdatedMethods)n(t,this);this.dispatchCustomEvent("peerProfileUpdated",t)}isMessageProcessing(){return this.currentSenderId!==null}getCurrentSender(){return this.currentSenderId===null?null:this.peers.get(this.currentSenderId)}isCurrentSenderSelf(){return this.currentSenderId===this.selfPeer.id}close(){var e;(e=this.ws)==null||e.close(),this.ws=null}sendPing(){var e;(e=this.ws)==null||e.send(JSON.stringify(C()))}handleOnOpen(e){var t;this.connecting=!0;for(const[o,n]of this.beforeEnterRoomMethods)n(this.selfPeer.profile,this);this.doSendMessage(j({room:this.room,selfPeer:this.selfPeer}));for(let o of this.interimQueue)(t=this.ws)==null||t.send(JSON.stringify(o));this.interimQueue=[]}handleOnClose(e){console.debug(`websocket closed because: ${e.reason}.`),this.connecting=!1,this.ws=null}handleOnError(e){}handleOnMessage(e){const t=JSON.parse(e.data);this.currentSenderId=t.sender;try{this.data(t)}finally{this.currentSenderId=null}}data(e){if(e.type!="Pong")if(e.type==="EnterRoomAllowed"){const t=e;for(const[o,n]of this.enterRoomAllowedMethods)n(t,this);this.room=e.room,this.selfPeer.order=e.selfPeer.order,this.peers.set(t.selfPeer.id,{...t.selfPeer,profile:this.selfPeer.profile});for(const o of t.otherPeers)this.peers.set(o.id,o);if(this.dispatchCustomEvent("enterRoomAllowed",t),e.histories)for(const o of e.histories)this.data(o)}else if(e.type==="EnterRoomDenied"){const o=e;for(const[n,i]of this.enterRoomDeniedMethods)i(o,this);this.dispatchCustomEvent("enterRoomDenied",o)}else if(e.type=="LeaveRoomDone"){for(const[t,o]of this.leaveRoomDoneMethods)o(this);this.dispatchCustomEvent("leaveRoomDone")}else if(e.type==="UpdateRoomProfile"){const t=e;if(e.updates)for(const[o,n]of Object.entries(e.updates))this.room.profile[o]=n;if(e.deletes)for(const o of e.deletes)delete this.room.profile[o];for(const[o,n]of this.roomProfileUpdatedMethods)n(t,this);this.dispatchCustomEvent("roomProfileUpdated",t)}else if(e.type==="PeerEntered"){const t=e;this.peers.set(t.peer.id,t.peer);for(const[o,n]of this.peerEnteredMethods)n(t,this);this.dispatchCustomEvent("peerEntered",t)}else if(e.type==="PeerLeaved"){const t=e;this.peers.delete(e.peerId);for(const[o,n]of this.peerLeavedMethods)n(t,this);this.dispatchCustomEvent("peerLeaved",t)}else if(e.type==="UpdatePeerProfile"){const t=this.peers.get(e.sender);if(e.sender&&t){if(e.updates)for(const[n,i]of Object.entries(e.updates))t.profile[n]=i;if(e.deletes)for(const n of e.deletes)delete t.profile[n];const o={...e,peerId:e.sender};for(const[n,i]of this.peerProfileUpdatedMethods)i(o,this);this.dispatchCustomEvent("peerProfileUpdated",o)}}else if(e.type==="InvokeFunction"){const t=`${e.funcId}`,o=this.shareOrNotifyFunctions.get(t);if(o===void 0){console.warn("no suitable function for ",e);return}const n=this.applyInvocation(o.original,e.args);n instanceof Promise&&n.then(()=>{var i;(i=o.resolve)==null||i.apply(null,arguments)}).catch(()=>{var i;(i=o.reject)==null||i.apply(null,arguments)})}else if(e.type==="UpdateObjectState"){const t=this.setStateMethods.get(e.objId);t&&t(e.state,e.objRevision);const o=this.shareObjects.get(e.objId);o&&(o.revision=e.objRevision,o.update=0)}else if(e.type==="InvokeMethod"){const t=this.shareObjects.get(e.objId);if(t===void 0){console.error(`Object not found for id: ${e.objId}.`,e);return}const o=`${e.objId}:${e.methodId}`,n=this.shareOrNotifyMethods.get(o);if(n===void 0){console.error(`Method not found for id: ${o}.`,e);return}n.config.share&&(n.config.share.type=="beforeExec"&&t.revision+1!==e.serverObjRevision&&console.error(`Found inconsistency. serverObjRevision must be ${t.revision+1} but ${e.serverObjRevision}.`,e),t.revision++,t.update++);const i=this.applyInvocation(n.original,e.args);i instanceof Promise&&i.then(()=>{var a;(a=n.resolve)==null||a.apply(null,arguments)}).catch(()=>{var a;(a=n.reject)==null||a.apply(null,arguments)})}else e.type?this.dispatchEvent(new CustomEvent(e.type,{detail:e})):console.warn("Unknown message type.",e)}isSystemMessageType(e){return e in this.systemMessageTypes}send(e,t,o="BROADCAST"){this.ws&&this.sendMessage({type:e,sender:this.selfPeer.id,castType:o,recipients:void 0,content:t})}unicast(e,t,o){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"UNICAST",recipients:[o],content:t})}multicast(e,t,o){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"MULTICAST",recipients:o,content:t})}broadcast(e,t){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"BROADCAST",recipients:void 0,content:t})}othercast(e,t){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"OTHERCAST",recipients:void 0,content:t})}sendMessage(e){if(this.isSystemMessageType(e.type))throw new Error("システムメッセージは送信できません。");this.doSendMessage(e)}addReceiver(e,t){if(this.isSystemMessageType(e))throw new Error("システムメッセージのレシーバは登録できません。");this.addEventListener(e,t)}removeReceiver(e,t){this.removeEventListener(e,t)}replacer(e,t){return t instanceof Map?Object.fromEntries(t):t}doSendMessage(e){var t;this.connecting?(t=this.ws)==null||t.send(JSON.stringify(e,this.replacer)):this.interimQueue.push(e)}registerFunction(e,t={share:{}}){if("hostOnly"in t)return this.addHostOnlyFunction(e,t);if("notify"in t){t.notify.type||(t.notify.type=w.type);const o=e.name,n=this.shareOrNotifyFunctions.size,i=this.createFunctionProxy(e,{notify:t.notify},n),a=function(){return i.apply(null,arguments)};return this.doSendMessage(b({definition:{funcId:n,name:o,config:t}})),a}else if("share"in t){t.share.type||(t.share.type=g.type),t.share.maxLog||(t.share.maxLog=g.maxLog);const o=e.name,n=this.shareOrNotifyFunctions.size,i=this.createFunctionProxy(e,{share:t.share},n),a=function(){return i.apply(null,arguments)};return this.doSendMessage(b({definition:{funcId:n,name:o,config:t}})),a}return e}register(e,t=[]){if(!this.ws)return e;const o=e;if(o.madoiObjectId_)return console.warn("Ignore object registration because it's already registered."),e;let n=o.constructor.name;o.__proto__.constructor.madoiClassConfig_&&(n=o.__proto__.constructor.madoiClassConfig_.className);const i=this.shareObjects.size,a={instance:o,revision:0,update:0};this.shareObjects.set(i,a),o.madoiObjectId_=i;const u=new Array,m=new Array,v=new Map;Object.getOwnPropertyNames(Object.getPrototypeOf(o)).forEach(p=>{const c=o[p];if(typeof c!="function"||!c.madoiMethodConfig_)return;const f=c.madoiMethodConfig_,l=u.length;v.set(p,l),u.push(c),m.push({methodId:l,name:p,config:f}),console.debug(`add config ${n}.${p}=${JSON.stringify(f)} from decorator`)});for(const p of t){const c=p.method,f=p,l=c.name;if("share"in f)f.share.type||(f.share.type=g.type),f.share.maxLog||(f.share.maxLog=g.maxLog);else if("notify"in f)f.notify.type||(f.notify.type=w.type);else if(!("hostOnly"in f)){if("getState"in f)f.getState.maxInterval||(f.getState.maxInterval=E.maxInterval);else if(!("setState"in f)){if(!("enterRoomAllowed"in f)){if(!("enterRoomDenied"in f)){if(!("leaveRoomDone"in f)){if(!("peerEntered"in f)){if(!("peerLeaved"in f))continue}}}}}}const A=v.get(l);if(typeof A>"u"){const L=u.length;v.set(l,L),u.push(c),m.push({methodId:L,name:p.method.name,config:f}),console.debug(`add config ${n}.${l}=${JSON.stringify(p)} from argument`)}else m[A].config=p,console.debug(`replace config ${n}.${l}=${JSON.stringify(p)} from argument`)}for(let p=0;p<u.length;p++){const c=u[p],f=m[p],l=f.config;"share"in l?o[f.name]=this.createMethodProxy(c.bind(o),{share:l.share},i,f.methodId):"notify"in l?o[f.name]=this.createMethodProxy(c.bind(o),{notify:l.notify},i,f.methodId):"hostOnly"in l?o[f.name]=this.addHostOnlyFunction(c.bind(o),l.hostOnly,i):"getState"in l?this.getStateMethods.set(i,{method:c.bind(o),config:l.getState,lastGet:0}):"setState"in l?this.setStateMethods.set(i,c.bind(o)):"beforeEnterRoom"in l?this.beforeEnterRoomMethods.set(i,c.bind(o)):"enterRoomAllowed"in l?this.enterRoomAllowedMethods.set(i,c.bind(o)):"enterRoomDenied"in l?this.enterRoomDeniedMethods.set(i,c.bind(o)):"leaveRoomDone"in l?this.leaveRoomDoneMethods.set(i,c.bind(o)):"peerEntered"in l?this.peerEnteredMethods.set(i,c.bind(o)):"peerProfileUpdated"in l?this.peerProfileUpdatedMethods.set(i,c.bind(o)):"peerLeaved"in l&&this.peerLeavedMethods.set(i,c.bind(o))}const P=D({definition:{objId:i,className:n,methods:m}});return this.doSendMessage(P),e}createFunctionProxy(e,t,o){const n=`${o}`,i={original:e,config:t};this.shareOrNotifyFunctions.set(n,i),i.promise=new Promise((u,m)=>{i.resolve=u,i.reject=m});const a=this;return function(){var u,m;if(a.ws===null){if(e)return e.apply(null,arguments)}else{let v=null,P="BROADCAST";return(((u=t.share)==null?void 0:u.type)==="afterExec"||((m=t.notify)==null?void 0:m.type)==="afterExec")&&(v=e.apply(null,arguments),P="OTHERCAST"),a.sendMessage(I(P,{funcId:o,args:Array.from(arguments)})),v??i.promise}}}createMethodProxy(e,t,o,n){const i=`${o}:${n}`,a={original:e,config:t};this.shareOrNotifyMethods.set(i,a),a.promise=new Promise((m,v)=>{a.resolve=m,a.reject=v});const u=this;return function(){var m,v;if(u.ws===null){if(e)return e.apply(null,[...arguments,u])}else{let P=null,p="BROADCAST";const c=u.shareObjects.get(o),f=c.revision;return(((m=t.share)==null?void 0:m.type)==="afterExec"||((v=t.notify)==null?void 0:v.type)==="afterExec")&&(P=e.apply(null,[...arguments,u]),t.share&&(c.revision++,c.update++),p="OTHERCAST"),u.sendMessage(U(p,{objId:o,objRevision:f,methodId:n,args:Array.from(arguments)})),P??a.promise}}}addHostOnlyFunction(e,t,o){const n=this;return()=>{if(n.isSelfPeerHost()){if(o!==void 0){const i=n.shareObjects.get(o);i.revision++,i.update++}e.apply(null,[...arguments,n])}}}saveStates(){if(!(!this.ws||!this.connecting)&&this.isSelfPeerHost())for(let[e,t]of this.shareObjects){if(t.update==0)continue;const o=this.getStateMethods.get(e);if(!o)continue;const n=performance.now();(o.config.maxUpdates&&o.config.maxUpdates<=t.update||o.config.maxInterval&&o.config.maxInterval<=n-o.lastGet)&&(this.doSendMessage(T({objId:e,objRevision:t.revision,state:o.method(this)})),o.lastGet=n,t.update=0,console.debug(`state saved: ${e}`))}}applyInvocation(e,t){return e.apply(null,t)}isSelfPeerHost(){for(const e of this.peers.values())if(e.order<this.selfPeer.order)return!1;return!0}}r.BeforeEnterRoom=J,r.EnterRoomAllowed=G,r.EnterRoomDenied=Q,r.GetState=x,r.HostOnly=B,r.LeaveRoomDone=z,r.Madoi=X,r.Notify=k,r.PeerEntered=V,r.PeerLeaved=W,r.PeerProfileUpdated=K,r.RoomProfileUpdated=q,r.SetState=H,r.Share=N,r.ShareClass=F,r.getStateConfigDefault=E,r.newDefineFunction=b,r.newDefineObject=D,r.newEnterRoom=j,r.newInvokeFunction=I,r.newInvokeMethod=U,r.newLeaveRoom=$,r.newPing=C,r.newUpdateObjectState=T,r.newUpdatePeerProfile=R,r.newUpdateRoomProfile=S,r.notifyConfigDefault=w,r.shareConfigDefault=g,Object.defineProperty(r,Symbol.toStringTag,{value:"Module"})});
